/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/options 
{
                             
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Parser)

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/
    public static void main(String[] args) throws ParseException {
        
        //Parser initialization
        Parser parser;

        if (args.length != 1){
            System.out.println ("Usage: java Parser <file_directory>");
            return;
        }
        else {
            System.out.println("Parser: Reading the file " + args[0] + " ..." );
            try {
                parser = new Parser(new java.io.FileInputStream(args[0]));
            }
            catch(java.io.FileNotFoundException e) {
                System.out.println ("Parser: The file " + args[0] + " was not found.");
                return;
            }
        }

        try {            
            SimpleNode root = parser.Program();
            System.out.println ("Parser: The input was readed sucessfully.");

            root.dump(""); // Prints syntax tree
        }
        catch(TokenMgrError e){
            System.out.println ("Parser: There was an error.");
            System.out.println (e.getMessage());
        }  
        catch(ParseException e){
            System.out.println ("Parser: There was an error during the parse.");            
            System.out.println (e.getMessage());
        }                 
    }
}

PARSER_END(Parser)

// Symbols that should be ignored
SKIP: {
    " " | "\n" | "\t" | "\r"
}

// Must ignore single and multi line comments
SKIP: {
    < "//" (~["\r", "\n"])* >
    | < "/*" > : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP :
{
    < "*/" > : DEFAULT
    | < ~[] >   
}

// Definition of terminal symbols
TOKEN:
{
    < AND: "&&" >
    | < LOWER : "<" >
    | < PLUS : "+" > 
    | < MINUS : "-" >
    | < TIMES : "*" >
    | < DIVIDE : "/" >
    | < LENGTH : "length" >
    | < OPEN_PAREN : "(" >
    | < CLOSE_PAREN : ")" >
    | < COMMA : "," >
    | < DOT : "." >
    | < OPEN_BRACK : "[" >
    | < CLOSE_BRACK : "]" >
    | < INT : "int" > 
    | < INTARRAY : "int[]" >
    | < NOT : "!" >
    | < NEW :  "new" >
    | < THIS : "this" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < ASSIGN : "=" >
    | < BOOLEAN : "boolean" >
    | < SEMI_COLON : ";" >
    | < WHILE : "while" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < OPEN_BRACES : "{" >
    | < CLOSE_BRACES : "}" >
    | < PUBLIC : "public" >
    | < RETURN : "return" >
    | < EXTENDS : "extends" >
    | < CLASS : "class" >
    | < INTEGER_LITERAL : (["0"-"9"])+ >
    | < IDENTIFIER : (["a"-"z","A"-"Z"]) (["a"-"z","A"-"Z","0"-"9","_"])* > 
    
}

// Definition of Terminal Leafs
void Id()    : {/*@bgen(jjtree) ID */
                SimpleNode jjtn000 = new SimpleNode(JJTID);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ID */
    try {
/*@egen*/
    t=<IDENTIFIER>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Type()      : {/*@bgen(jjtree) TYPE */
                    SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) TYPE */
    try {
/*@egen*/
    (t=<INTARRAY> | t=<INT> | t=<BOOLEAN> | t=<IDENTIFIER>)/*@bgen(jjtree)*/
                                                           {
                                                             jjtree.closeNodeScope(jjtn000, true);
                                                             jjtc000 = false;
                                                           }
/*@egen*/{jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Grammar Definition
SimpleNode Program()         : {/*@bgen(jjtree) PROGRAM */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PROGRAM */
    try {
/*@egen*/
    ClassDeclaration() <EOF>/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                             }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassDeclaration()       : {/*@bgen(jjtree) CLASS */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CLASS */
    try {
/*@egen*/
    <CLASS>
    Id()
    (<EXTENDS> Id())? 
    <OPEN_BRACES> (VarDeclaration())* (MethodDeclaration())* <CLOSE_BRACES>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDeclaration()     : {/*@bgen(jjtree) VAR */
  SimpleNode jjtn000 = new SimpleNode(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VAR */
    try {
/*@egen*/
    Type() Id() <SEMI_COLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethodDeclaration()        : {/*@bgen(jjtree) METHOD */
  SimpleNode jjtn000 = new SimpleNode(JJTMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) METHOD */
    try {
/*@egen*/
    <PUBLIC> Type() Id() <OPEN_PAREN> Params() <CLOSE_PAREN> <OPEN_BRACES> [MethodBody()] <RETURN> Expression() <SEMI_COLON> <CLOSE_BRACES>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Params()            : {/*@bgen(jjtree) PARAMETERS */
  SimpleNode jjtn000 = new SimpleNode(JJTPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PARAMETERS */
    try {
/*@egen*/
    (Type() Id() (<COMMA> Type() Id())*)?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethodBody(): {} 
{   
    (<INTARRAY> | <INT> | <BOOLEAN>) <IDENTIFIER> <SEMI_COLON> MethodBody()  
    | <IDENTIFIER> (<IDENTIFIER> <SEMI_COLON> MethodBody() | IdStatement() (Statement())*)
    | NoIdStatement() (Statement())*
    
}

void IdStatement(): {} 
{   
    (
        (Op() Expression() | <DOT> (<LENGTH> | <IDENTIFIER> <OPEN_PAREN> (ExpParams())? <CLOSE_PAREN>)) NextExps()
        | <OPEN_BRACK> Expression() <CLOSE_BRACK> (<ASSIGN> Expression() | NextExps())
        | <ASSIGN> Expression()
    ) <SEMI_COLON>
}

void NoIdStatement(): {}
{   
    <OPEN_BRACES> (Statement())* <CLOSE_BRACES>
    | <IF> <OPEN_PAREN> Expression() <CLOSE_PAREN> Statement() <ELSE> Statement()
    |   <WHILE> try {            
            <OPEN_PAREN> Expression() <CLOSE_PAREN>
        }
        catch (ParseException e) {   
            System.out.println(e.toString());  // Print the error message         
            error_skip();            
        }
        catch (TokenMgrError e) {
            System.out.println(e.toString());  // Print the error message
            error_skip();            
        }
        Statement()
    | Exp1() NextExps() <SEMI_COLON>
}

void Statement(): {}
{
    NoIdStatement() 
    | <IDENTIFIER> IdStatement()
}

void Expression(): {}
{   
    Exp() NextExps()
}

void NextExps(): {}
{      
    (LOOKAHEAD(2) (Op() Expression() | <OPEN_BRACK> Expression() <CLOSE_BRACK> | <DOT> (<LENGTH> | <IDENTIFIER> <OPEN_PAREN> (ExpParams())? <CLOSE_PAREN>)))*
}

void Exp(): {}
{   
    <IDENTIFIER>
    | Exp1()
}

void Exp1():{}
{
    <INTEGER_LITERAL>
    | <TRUE>
    | <FALSE> 
    | <THIS>
    | <NEW> (<INT> <OPEN_BRACK> Expression() <CLOSE_BRACK> | <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>)
    | <NOT> Expression()
    | <OPEN_PAREN> Expression() <CLOSE_PAREN>
}

void ExpParams(): {}
{
    Expression() (<COMMA> Expression())*    
}

void Op(): {}
{
    <AND> 
    | <LOWER>
    | <PLUS>
    | <MINUS> 
    | <TIMES>
    | <DIVIDE>
}

JAVACODE
void error_skip() {
    Token t = getToken(1);

    while(t.kind != CLOSE_PAREN && t.kind != OPEN_BRACES && t.kind != IF && t.kind != WHILE && t.kind != SEMI_COLON) {        
        t = getNextToken();    
    }

    if(t.kind == CLOSE_PAREN || t.kind == SEMI_COLON) {
        getNextToken(); 
    }        
}