options 
{
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Parser)

public class Parser {
    public static void main(String[] args) throws ParseException {
        Parser parser = new Parser(System.in);
        parser.Program();

    }
}

PARSER_END(Parser)

// Symbols that should be ignored
SKIP: {
    " " | "\n" | "\t" | "\r"
}

// Definition of terminal symbols
TOKEN:
{
    < AND: "&&" >
    | < LOWER : "<" >
    | < PLUS : "+" > 
    | < MINUS : "-" >
    | < TIMES : "*" >
    | < DIVIDE : "/" >
    | < LENGTH : "length" >
    | < OPEN_PAREN : "(" >
    | < CLOSE_PAREN : ")" >
    | < COMMA : "," >
    | < DOT : "." >
    | < OPEN_BRACK : "[" >
    | < CLOSE_BRACK : "]" >
    | < INT : "int" > 
    | < INTARRAY : "int[]" >
    | < NOT : "!" >
    | < NEW :  "new" >
    | < THIS : "this" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < ASSIGN : "=" >
    | < BOOLEAN : "boolean" >
    | < SEMI_COLON : ";" >
    | < WHILE : "while" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < OPEN_BRACES : "{" >
    | < CLOSE_BRACES : "}" >
    | < PUBLIC : "public" >
    | < RETURN : "return" >
    | < EXTENDS : "extends" >
    | < CLASS : "class" >
    | < INTEGER_LITERAL : (["0"-"9"])+ >
    | < IDENTIFIER : (["a"-"z","A"-"Z"]) (["a"-"z","A"-"Z","0"-"9","_"])* > 
    |< EMPTY : "" >
    : MATCH_NON_EMPTY // change state, or infinite matches of the empty string could result
}

// Definition of epsilon token
<MATCH_NON_EMPTY>
TOKEN : {
    < NON_EMPTY : ~[] >
}

void Program(): {}
{
    ClassDeclaration() <EOF>
}

void ClassDeclaration(): {} {
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <OPEN_BRACES> (VarDeclaration())* (MethodDeclaration())* <CLOSE_BRACES>
}

void VarDeclaration(): {}
{
    Type() <IDENTIFIER> <SEMI_COLON>
}

void Type(): {}
{
    (<INTARRAY> | <INT> | <BOOLEAN> | <IDENTIFIER>)
}

void MethodDeclaration(): {}
{
    <PUBLIC> Type() <IDENTIFIER> <OPEN_PAREN> Params() <CLOSE_PAREN> <OPEN_BRACES> MethodVars() (Statement())* <RETURN> Expression() <SEMI_COLON> <CLOSE_BRACES>
}

void Params(): {}
{
    (Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*)?
}

void MethodVars(): {} 
{   
    (<INTARRAY> | <INT> | <BOOLEAN>) <IDENTIFIER> <SEMI_COLON> MethodVars()  
    | <IDENTIFIER> MaybeStatement()
    | <EMPTY>
}

void MaybeStatement(): {} 
{
    <IDENTIFIER> <SEMI_COLON> MethodVars()
    | IdStatement()
}

void IdStatement(): {} 
{   
    (
        (Op() Expression() | <DOT> (<LENGTH> | <IDENTIFIER> <OPEN_PAREN> (ExpParams())? <CLOSE_PAREN>)) NextExps()
        | <OPEN_BRACK> Expression() <CLOSE_BRACK> (<ASSIGN> Expression() | NextExps())
        | <ASSIGN> Expression()
    ) <SEMI_COLON>
}

void Statement(): {}
{
    <OPEN_BRACES> (Statement())* <CLOSE_BRACES>
    | <IF> <OPEN_PAREN> Expression() <CLOSE_PAREN> Statement() <ELSE> Statement()
    | <WHILE> <OPEN_PAREN> Expression() <CLOSE_PAREN> Statement()
    | <IDENTIFIER> IdStatement()
    | Exp1() NextExps() <SEMI_COLON>
}

void Expression(): {}
{   
    Exp() NextExps()
}

void NextExps(): {}
{
    (Op() Expression() | <OPEN_BRACK> Expression() <CLOSE_BRACK> | <DOT> (<LENGTH> | <IDENTIFIER> <OPEN_PAREN> (ExpParams())? <CLOSE_PAREN>))
    | <EMPTY>
}

void Exp(): {}
{   
    <IDENTIFIER>
    | Exp1()
}

void Exp1():{}
{
    <INTEGER_LITERAL>
    | <TRUE>
    | <FALSE> 
    | <THIS>
    | <NEW> (<INT> <OPEN_BRACK> Expression() <CLOSE_BRACK> | <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>)
    | <NOT> Expression()
    | <OPEN_PAREN> Expression() <CLOSE_PAREN>
}

void ExpParams(): {}
{
    Expression() (<COMMA> Expression())*    
}

void Op(): {}
{
    <AND> 
    | <LOWER>
    | <PLUS>
    | <MINUS> 
    | <TIMES>
    | <DIVIDE>
}